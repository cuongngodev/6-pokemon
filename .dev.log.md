## Dev Log

Before implementing any features, I reviewed the lecture materials and revisited the Pokémon codebase to refresh my understanding of the game’s flow. This helped me see how elements are rendered, how stats are calculated, and how the state stack manages transitions.

The first two features were straightforward. By following the structure of the existing code, features 3 and 4 were also manageable once I identified the correct parts of the codebase to extend or reuse.

### Roadblocks & Solutions
- **Health becoming `NaN`:**  
  Caused by forgetting to pass the `type` property into the `Pokemon` constructor. Adding the missing parameter fixed the issue.

- **Experience bar tween persisting into the next battle:**  
  The floating-point precision caused the condition `currentExp !== targetExp` to always be true. Fixed by using `Math.abs()` to compare values safely.

- **Missing sound assets for type effectiveness:**  
  The sounds didn’t play because they were not registered in `assets.json`. Adding the missing entries solved it.

- **Type effectiveness logic complexity:**  
  Integrating effectiveness factors required coordinating multiple classes to ensure consistent damage calculation, messages, and sound effects. Although tricky, it was one of the most interesting parts and helped me understand the system more deeply.

After implementing each feature, I tested repeatedly by playing through battles and logging key parameters to confirm that values changed correctly.

### AI Usage
I used AI as a tutor to clarify requirements, ensure I understood the logic before implementing, and verify the flow of the assignment. This prevented misinterpretation and helped me start with a solid plan.
